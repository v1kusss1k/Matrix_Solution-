# Задача 329. Longest Increasing Path in a Matrix

**Условие задачи**

Дана матрица размером m × n с целыми числами. Требуется найти длину самого длинного возрастающего пути в матрице. Из каждой клетки можно двигаться в четырех направлениях: влево, вправо, вверх или вниз. Движение по диагонали или выход за границы матрицы запрещены (то есть нельзя двигаться по кругу). Путь называется возрастающим, если значения в последовательных клетках строго возрастают.

Ограничения:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
0 <= matrix[i][j] <= 2^31 - 1

Пример 1:
[9, 9, 4]
[6, 6, 8]
[2, 1, 1]

Входные данные: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Выходные данные: 4
Пояснение: Самый длинный возрастающий путь — [1, 2, 6, 9].

Пример 2:
[3,4,5]
[3,2,6]
[2,2,1]

Входные данные: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Выходные данные: 4
Пояснение:  Самый длинный возрастающий путь — [3, 4, 5, 6]. Перемещение по диагонали запрещено.

Задача заключается в поиске максимально возможной длины пути, вдоль которого значения в клетках строго возрастают. При этом путь может начинаться в любой клетке матрицы, а направление движения не фиксировано заранее. Основная сложность заключается в том, что локально оптимальный выбор (например, переход в ближайшую большую клетку) не гарантирует глобально оптимального решения, так как более длинный путь может начинаться с меньшего значения в другой части матрицы.
Таким образом, требуется рассмотреть все возможные варианты начала пути и для каждого из них определить максимальную длину возрастающей последовательности.

# Алгоритм решения

**Основные наблюдения и теоретические предпосылки**

1. Графовое представление задачи
Рассмотрим матрицу как ориентированный граф: 
  - каждая клетка (i,j) соответствует вершине графа;
  - существует ориентированное ребро из клетки (i,j) в клетку (x,y), если:
    - клетки являются соседними по стороне;
    - matrix[x][y] > matrix[i][j]
    
Так как рёбра всегда направлены от меньшего значения к большему, полученный граф является ориентированным ациклическим графом (DAG). Это свойство принципиально важно для корректности алгоритма.

2. Свойство оптимальной подструктуры
Обозначим через LIP(i,j) длину самого длинного возрастающего пути, начинающегося в клетке (i,j).
Тогда справедливо следующее рекуррентное соотношение: 
LIP(i,j) = 1 + maxLIP(x,y), если существует сосед (x,y), такой что matrix[x][y] > matrix[i][j], иначе 1
 
То есть либо путь продолжается в одну из соседних клеток с большим значением, либо он состоит только из текущей клетки.

**Жадный алгоритм не подходит**

Жадный подход, при котором из каждой клетки выбирается сосед с наибольшим значением, не гарантирует нахождение оптимального решения. Это связано с тем, что переход к локально максимальному соседу может привести к быстрому завершению пути, тогда как выбор меньшего значения на текущем шаге может открыть доступ к более длинной возрастающей цепочке в будущем. Следовательно, решение должно учитывать все возможные продолжения пути, а не только локально лучший выбор.

**Лемма 1 (Корректность мемоизации)**

В ориентированном ациклическом графе, построенном по матрице, значение LIP(i,j) может быть вычислено с использованием мемоизации, причём каждое значение будет вычислено не более одного раза.

Доказательство:
Поскольку все рёбра направлены от меньших значений к большим, при вычислении LIP(i,j) мы обращаемся только к вершинам, соответствующим клеткам с большими значениями. Следовательно, невозможно вернуться в уже посещённую клетку в рамках одного рекурсивного пути, то есть циклы отсутствуют. Это гарантирует, что каждая подзадача вычисляется единственный раз, а сохранённый результат можно безопасно переиспользовать.

**Необходимость мемоизации**

Если для каждой клетки выполнять DFS без сохранения промежуточных результатов, одни и те же подзадачи будут вычисляться многократно. В худшем случае это приведёт к экспоненциальному времени работы алгоритма. Использование массива dp позволяет сохранить результат для каждой клетки и гарантирует, что каждая подзадача будет решена ровно один раз.

**Лемма 2 (Оптимальность рекуррентного соотношения)**

Рекуррентное соотношение для LIP(i,j) даёт оптимальное решение для задачи длины возрастабщего пути.

Доказательство:
Рассмотрим самый длинный возрастающий путь, начинающийся в клетке (i,j): (i,j) → (x1,y1) → (x2,y2) → ⋯ → (xk,yk) Очевидно, что подпуть, начинающийся в клетке (x1,y1), также должен быть максимально возможным. В противном случае его можно заменить на более длинный, что приведёт к увеличению длины исходного пути, что противоречит предположению об оптимальности. Следовательно, оптимальное решение удовлетворяет указанной рекуррентной формуле.

**Отсутствие циклов в графе**

Циклы в графе невозможны, так как каждое ребро направлено от меньшего значения к большему. Если бы существовал цикл, это означало бы наличие последовательности клеток, в которой значения строго возрастают и при этом возвращаются к исходной клетке, что невозможно. Это свойство гарантирует ацикличность графа и корректность использования DFS.

**Лемма 3 (Связь с топологической сортировкой)**

Значения LIP(i,j) могут быть вычислены в порядке топологической сортировки графа.

Доказательство:
Так как граф ацикличен, для него существует топологический порядок. Если вычислять значения LIP в обратном топологическом порядке (от вершин без исходящих рёбер к остальным), то при вычислении значения для каждой клетки все необходимые значения для соседей уже будут известны. Использование DFS с мемоизацией неявно реализует именно такой порядок вычислений

**Граничные случаи**

Алгоритм корректно обрабатывает следующие граничные ситуации:
  - матрица размера 1 × 1, в этом случае ответ равен 1;
  - матрица, в которой все элементы равны — любой путь имеет длину 1;
  - строго возрастающая матрица, где путь может проходить через все клетки;
  - строго убывающая матрица, в которой каждый путь состоит из одной клетки.

# Описание алгоритма

1. Инициализация
  Создаётся матрица dp размером m × n, заполненная нулями. Значение dp[i][j] = 0 означает, что длина пути    из клетки (i,j) ещё не вычислена.
2. Поиск в глубину с мемоизацией
  Для каждой клетки (i,j) вызывается рекурсивная функция DFS: 
    - если dp[i][j] ≠ 0, возвращается сохранённое значение;
    - иначе инициализируется max_len = 1;
    - для каждого из четырёх направлений проверяется соседняя клетка;
    - если сосед существует и его значение строго больше текущего, выполняется рекурсивный вызов DFS;
    - результат сохраняется в dp[i][j].
3. Получение ответа
  Ответом является максимальное значение среди всех dp[i][j].

**Почему требуется перебор всех начальных клеток?**

Так как путь может начинаться в любой клетке матрицы, заранее неизвестно, какая из них является началом оптимального пути. Поэтому необходимо вычислить значение LIP(i,j) для всех клеток и выбрать максимальное из них как итоговый ответ.

# Корректность алгоритма

Из лемм 1–3 следует, что алгоритм: 
  - корректно обрабатывает все возможные пути;
  - не допускает повторных вычислений;
  - находит оптимальное значение для каждой клетки.
Следовательно, алгоритм всегда возвращает длину самого длинного возрастающего пути в матрице.

# Анализ сложности

**Временная сложность — асимптотика**

1. Инициализация матрицы dp: O(m ⋅ n).
2. DFS с мемоизацией: каждая клетка обрабатывается один раз, для каждой клетки проверяется до 4 соседей. Общее количество операций: O(m ⋅ n).
3. Обход всех клеток для поиска максимума: O(m ⋅ n).

Итоговая временная сложность: O(m ⋅ n)

**Затраты памяти**

1. Матрица dp: O(m ⋅ n).
2. Стек рекурсии DFS: в худшем случае O(m ⋅ n)
3. Вспомогательные переменные: O(1)

Итоговые затраты памяти: O(m ⋅ n)

**Вывод**

В данной задаче была использована комбинация поиска в глубину и динамического программирования с мемоизацией. Представление матрицы в виде ориентированного ациклического графа позволило строго обосновать корректность алгоритма. Предложенное решение эффективно по времени и памяти и укладывается в заданные ограничения.
